<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Pink : Pink is a framework to develop a modern web application quickly and easily using the Java EE stack." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Pink</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/bibhas2/Pink">View on GitHub</a>

          <h1 id="project_title">Pink Documentation</h1>
<a class="blue-btn" href="index.html">Home</a>
<a class="blue-btn">Download</a>

<!--
            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/bibhas2/Pink/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/bibhas2/Pink/tarball/master">Download this project as a tar.gz file</a>
            </section>
-->
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>Getting Started</h2>

<h3>Supported Servers</h3>

<p>Pink requires a CDI compatible web container. It has been tested in JBoss AS 7 and TomEE Web profile 1.5.0. Pink will not work in a plain Tomcat server.</p>

<h3>Create a Web Project</h3>

<p>To use Pink, create a basic Dynamic Web project in Eclipse. Add Pink.jar to WEB-INF/lib. If you plan on using the JSON serialization, then add these JAR files to WEB-INF/lib:</p>

<ol>
<li>jackson-annotations-2.1.1.jar</li>
<li>jackson-core-2.1.1.jar</li>
<li>jackson-databind-2.1.1.jar</li>
</ol><p>Register the Pink Servlet in web.xml.</p>

<pre><code>&lt;servlet&gt;
  &lt;servlet-name&gt;Pink Servlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;com.mobiarch.nf.Controller&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;Pink Servlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>

<p>Finally, make sure that you have a <strong>beans.xml</strong> file in WEB-INF folder to enable CDI.</p>

<p>You can use the PinkTest web project to see how these things are done.</p>

<h2>Basic Programming</h2>
<h3>Model View Controller</h3>

<p>A controller is a CDI managed bean. Here is a simple controller.</p>

<pre><code>@Named("simple")
@RequestScoped
public class MySimpleController {
    String fullName;
    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }
    //Action handler method
    public String hello() {
        return "greet";
    }
}
</code></pre>

<p>Here, hello() is an action handler method. It is returning a String outcome. For a GET request, Pink treats the outcome to be a JSP file name (without the .jsp). By default, the file name is relative to the bean's name. So, create a JSP file called <strong>/simple/greet.jsp</strong> under the WebContent folder.</p>

<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Hi, ${simple.fullName}!&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Now, you can send a request to the hello() method, using the URI <strong>/app/simple/hello?fullName=Daffy</strong>. For example, if your web app's context root is SimpleWeb and the server is listening on port 8080, the full URL will be <strong>http://localhost:8080/SimpleWeb/app/simple/hello?fullName=Daffy</strong>. This will show a page saying "Hi, Daffy!".</p>

<p>The URI is very easy to form. Here, "simple" refers to the controller bean by its name. Then "hello" is a path that points to the hello() method. The "fullName" URL parameter sets the fullName property of the bean.</p>

<h3>Form Submission Handling</h3>

<p>Pink uses simple URL parameter naming convention. As you have seen above, to update the fullName property of the controller, you send a URL parameter called fullName. It's that simple. A set of custom tags are provided to make your life even easier when designing forms.</p>

<p>Consider a controller:</p>

<pre><code>
@Named("customers")
@RequestScoped
public class CustomerController {
    Logger logger = Logger.getLogger(getClass().getName());
    Customer customer = new Customer();
    @Inject
    Context context; //Pink request context

    public String register() {
        if (context.isPostBack()) {
                logger.fine("Registering: " + customer.getFullName() + 
                    " Email: " + customer.getEmail());
                //Create customer record in database...

                return "show?customer.id=" + 100;
            } else {
                return "new_customer_form";
            }
    }
    public String show() {
         logger.fine("Showing customer: " + customer.id);

        return "display_customer";
    }
}

public class Customer {
    private String id;
    private String fullName;
    private String email;

    //Getters and setters...
}
</code></pre>

<p>The register() method calls <strong>context.isPostBack()</strong> to handle a GET and POST request differently. A GET request shows the registration form. When the form is submitted, a POST request is sent which creates a new customer in the database.</p>

<p>The form needs to be created in <strong>/customers/new_customer_form.jsp</strong> since the outcome returned by register() after a GET request is "new_customer_form". The JSP will look like this:</p>

<pre><code>&lt;%@ taglib uri="http://mobiarch" prefix="p" %&gt;
&lt;html&gt;
&lt;body&gt;

&lt;p:form action="customers/register" method="post"&gt;
  Name: &lt;p:input type="text" name="customer.fullName"/&gt;&lt;br/&gt;
  E-mail: &lt;p:input type="text" name="customer.email"/&gt;&lt;br/&gt;
  &lt;input type="submit" value="Add Customer"/&gt;
&lt;/p:form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>The action of the form is "customers/register". This will invoke the the register() method of our bean. The name attribute of the <strong>p:input</strong> tag refers to the property names of the bean. </p>

<p>To view the form, send a GET request for the URI: <strong>/app/customers/register</strong>. After the form is submitted, register() will be called again, this time using a POST request. This time, the method returns the outcome "show?customer.id=100". As a best practice, POST should result in a redirection. Pink enforces that behavior by default. This outcome will redirect the browser to <strong>/app/customers/show?customer.id=100</strong>. This time show() will be called which will load /customers/display_customer.jsp.</p>

<blockquote>
<p>Pink JSP tags can take any arbitrary attributes. That means, you can use the new HTML5 attributes or any custom attributes to drive a modern jQuery based application.</p>
</blockquote>

<blockquote>
You can use one method that shows the form and another one that handles the form submission. Using a single method, as we do here, will make things more manageable. You use the same meaningful URL for the two operations, but use HTTP method to differentiate the behavior.
</blockquote>

<h3>Form Validation</h3>

<p>Pink uses JSR 303 for form validation. We can annotate the fields of the Customer class to set the validation rules.</p>

<pre><code>@Size(min=3, max=15, message="The name must be at least 3 and maximum 15 characters long")
private String fullName;
@Size(min=3, max=25, message="Please enter a valid e-mail")
private String email;
</code></pre>

<p>Now, the register method should re-display the form if validation fails. We check for validation failure by calling context.isValidationFailed().</p>

<pre><code>public String register() {
    if (context.isPostBack() <strong>&amp;&amp; context.isValidationFailed() == false</strong>) {
        logger.fine("Registering: " + customer.getFullName() + 
            " Email: " + customer.getEmail());
        //Create customer record in database...

        return "show?customer.id=" + 100;
    } else {
        return "new_customer_form";
    }
}
</code></pre>

<p>Finally, show the error messages above the form.</p>

<pre><code>&lt;p:errors style="color: red"/&gt;
&lt;p:form action="customers/register" method="post"&gt;
...
&lt;/p:form&gt;
</code></pre>

<p>You can set any attribute for <strong>p:errors</strong>. Here we set the style attribute.</p>

<h3>SEO Friendly Clean URL</h3>
<p>
Right now, we are invoking the show() method by requesting the URI "/app/customers/show?customer.id=100". This is awkward and search engines will not crawl this link. Pink allows you to set any URL parameter in the URI path. Here, we will make a few changes so that we can call the show() method using the URI <strong>/app/customers/show/100</strong>.
</p>

<p>
Annotate the register() method with com.mobiarch.nf.Path.
</p>
<pre>
@Path("customer.id")
public String show() {
    ...
}
</pre>
<p>
That's it. now, Pink will get the path segment after the method name - show - and set it as the value of the customer.id property of the bean. @Path let's you set any number of properties separated by "/".
</p>
<p>The old query string based URI will continue to work. If a parameter appears in both URL parameter as well as in the URI path, the latter takes precedence. 
</p>
<p>Although optional, you should probably change the redirected URI in your code.</p>
<pre><code>public String register() {
    if (context.isPostBack() &amp;&amp; context.isValidationFailed() == false) {
	...

        return <strong>"show/" + 100;</strong>
    } else {
        return "new_customer_form";
    }
}
</code></pre>

<p>
By default, the path for a method is same as its name. If the method name is too long, or you do not wish to expose the method name, you can assign a different path. For example:
</p>
<pre>
@Path(<strong>"/show/customer.id"</strong>)
public String showCustomerDetails() {
    ...
}
</pre>
<p>
Here, we are assigning the path "show" to the method showCustomerDetails.
</p>

<blockquote>
There is no way to assign a different path to the controller bean itself. You must use the CDI name of the bean in the URI.
</blockquote>

<h3>JSON Response</h3>
<p>Pink makes it very easy to send a JSON document back in response. You can use this feature to aid Ajax communication.</p>
<p>
Normally, an action handler method of a controller bean returns an outcome string. This is used to either redirect the browser or load a JSP. If, on the other hand, the method returns a non-String object, Pink converts it into a JSON document and sends it back to the browser. The content type is set to "application/json" in that case. Example:
</p> 

<pre>
@Path("customer.id")
public Customer get() {
    logger.fine("get() called with id: " + customer.getId());
    Customer c = ...; //Load Customer from database...

    return c;
}
</pre>
<p>
You can send a GET request for the URI /app/customers/get/100. This will return something like:
</p>
<pre>
{"id":"100","fullName":"Daffy Duck","email":"daffy@wb.com"}
</pre>

<h2>Advanced Topics</h2>
<h3>Redirecting After a GET</h3>
<p>
Pink automatically does a redirection after a POST. But, after a GET, it forwards to a JSP page indicated by the outcome string. In some situations, you may need to do a redirection after a GET. In that case, prefeix the outcome string with a "@". For example: 
</p>
<pre>
@Named("customers")
@RequestScoped
public class CustomerController {
...

    @Path("customer.id")
    public String delete() {
        logger.fine("Deleting: " + customer.getId());

        //Delete customer from database

        return <strong>"@list"</strong>;
    }

    public String list() {
        //Get customer list from database...

        return "customer_list";
    }
}
</pre>

<p>
You can send a request for delete() using <strong>/app/customers/delete/100</strong>. The response will redirect the browser to <strong>/app/customers/list</strong>. This will execute the list() method. Based on its outcome, Pink will load /customers/customer_list.jsp.
</p>
<h3>Redirect to a Different Controller Bean</h3>
<p>
By default, a redirection outcome is relative to the current bean. For example, when register() returns "show", the browser is redirected to "/app/customers/show". In some situations, a bean may need to navigate to another bean. In that case, use an absolute outcome value. For example:
</p>
<pre>
@Named
@RequestScoped
public class BeanA {
    public String aMethod() {
        return <strong>"/beanB/bMethod"</strong>;
    }
}

@Named
@RequestScoped
public class BeanB {
    public String bMethod() {
        return "form";
    }
}
</pre>
<p>
The aMethod() method of BeanA returns an absolute redirection outcome. If this method is invoked after a POST request, Pink will redirect the browser to <strong>/app/beanB/bMethod</strong>. This time, bMethod() of BeanB will be called. This method will load /beanB/form.jsp.
</p>
<h3>Load a JSP from Any Folder</h3>
<p>
By default, Pink loads a JSP file relative to the current bean. For example, when list() returns customer_list outcome, Pink loads /customers/customer_list.jsp. To load a JSP from any other folder, return an absolute outcome. For example:
</p>
<pre>
@Named("customers")
@RequestScoped
public class CustomerController {
...

    public String list() {
        //Get customer list from database...

        return <strong>"/dir1/dir2/customer_list"</strong>;
    }
}
</pre>
<p>
If list() is called after a GET request, Pink will load /dir1/dir2/customer_list.jsp.
</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Pink maintained by <a href="https://github.com/bibhas2">bibhas2</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
